---
layout: post
title: "Reactive systems using Reactor"
date: 2016-11-15 09:00:00 -0600
categories: java
---
[Reactor][reactor] 3.x is a Java library for writing [reactive][manifesto]
applications using the [Reactive Streams][rs] standard. [Reactor Core][rc]
provides a reactive streams implementation similar in style to
[RxJava 2][rxjava2]. Because it is based on standard reactive streams, Reactor
can easily integrate with any other reactive streams library (particularly
RxJava 2). There are adapters available for RxJava 1 and the
[`CompleteableFuture`][compfut] API as well as conversions for the new JDK 9
[`Flow`][flow] reactive stream interfaces. Reactor also provides an [IPC][ipc]
API for implementing reactive streams systems for general networking and off-JVM
communication. The main implementation of the IPC API is [Reactor Netty][rn]
which provides TCP, UDP, and HTTP DSLs. There are other modules in the works,
but Reactor 3.x is still under heavy development.

## Reactive Streams
Reactive streams are an API and pattern to handling streams of data
asynchronously and non-blocking while providing backpressure to stream
publishers so that stream subscribers do not get overwhelmed and require
maintaining internal buffers or cause blocking. The reactive streams
standard provides the minimal API to support this style of architecture
which is also being introduced in Java 9.

The main classes in this API are `Publisher<T>` and `Subscriber<T>`. A
`Publisher` is the source of events `T` in the stream, and a `Subscriber` is
the destination for those events. The basic idea of how these classes
interact is that a `Subscriber` subscribes to a `Publisher` which invokes
`Subscriber::onSubscribe(Subscription)`. When the `Subscriber` is ready to
start handling events, it signals this via a request to that `Subscription`
Upon receiving this signal, the `Publisher` begins to invoke
`Subscriber::onNext(T)` for each event `T`. This continues until either
completion of the stream (`Subscriber::onComplete()`) or an error occurs
during processing (`Subscriber::onError(Throwable)`).

## Reactor
Clearly, the reactive streams API is too low level to make practical use of it
in reactive applications. This is where Reactor Core (or RxJava) come into play
by providing a DSL for handling these streams. Reactor provides two main types
of publishers: [`Flux`][flux] and [`Mono`][mono]. A `Flux` is a general purpose
publisher that can contain an unbounded number of events. A `Mono` is a specialized
publisher that can contain only zero or one events. For a hands-on introduction
to these classes, take a look at [this GitHub project][handson] and try to
implement all the test stubs. We'll go over some of the tests below.

## Trying Out Reactor
As a neat way to get familiar with the Reactor Core API, we'll be implementing
the code necessary to pass these test stubs. These tests will cover `Flux`,
`Mono`, `Scheduler`, `StepVerifier`, and bridges to other APIs.

### Flux
Our first task is to create an empty `Flux`. Such a `Flux` will publish no events
and will immediately complete without error. `Flux` provides a static factory
method for creating such a `Flux`:

```java
Flux<String> emptyFlux() {
    return Flux.empty();
}
```

Our next task is to create a `Flux` that will stream through two strings and
complete. `Flux` provides another static factory method for this:

```java
Flux<String> fooBarFluxFromValues() {
    return Flux.just("foo", "bar");
}
```

Next, we need to create a `Flux` from a standard `List` collection. Again, we
can use a factory method:

```java
Flux<String> fooBarFluxFromList() {
    return Flux.fromIterable(Arrays.asList("foo", "bar"));
}
```

Next, we want a `Flux` that errs immediately instead of completing normally.
Did you guess that there's a factory method for it?

```java
Flux<String> errorFlux() {
    return Flux.error(new IllegalStateException());
}
```

Finally, we start to get a little interesting by creating a `Flux` that emits
the sequence 0 through 9, and each emission should be spaced out by 100 ms.
Here we'll use the `Flux.interval()` factory and limit it to only 10 items:

```java
Flux<Long> counter() {
    return Flux.interval(Duration.ofMillis(100)).take(10);
}
```

[reactor]: https://projectreactor.io/
[manifesto]: http://www.reactivemanifesto.org/
[rs]: http://www.reactive-streams.org/
[rxjava2]: https://github.com/ReactiveX/RxJava/tree/2.x
[compfut]: http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html
[flow]: http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java/util/concurrent/Flow.html
[rc]: https://github.com/reactor/reactor-core
[ipc]: https://github.com/reactor/reactor-ipc
[rn]: https://github.com/reactor/reactor-netty
[handson]: https://github.com/reactor/lite-rx-api-hands-on
[flux]: http://projectreactor.io/core/docs/api/reactor/core/publisher/Flux.html
[mono]: http://projectreactor.io/core/docs/api/reactor/core/publisher/Mono.html
